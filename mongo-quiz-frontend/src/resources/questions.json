[
  {
    "numId": 6,
    "description": "Quelle est la commande MongoDB pour afficher toutes les bases de données disponibles sur ton serveur ?",
    "level": 1,
    "options": [
      { "id": 1, "query": "show dbs" },
      { "id": 2, "query": "list databases" },
      { "id": 3, "query": "display dbs" },
      { "id": 4, "query": "mongo.showDbs()" }
    ],
    "correctOptionId": 1,
    "explanation": "La commande **`show dbs`** est la syntaxe standard et correcte pour lister toutes les bases de données dans le shell MongoDB. Les autres options (`list databases`, `display dbs`, `mongo.showDbs()`) ne sont pas des commandes MongoDB valides."
  },
  {
    "numId": 7,
    "description": "Comment te connectes-tu à la base de données `mongolingo_db` dans le shell MongoDB ?",
    "level": 1,
    "options": [
      { "id": 1, "query": "connect mongolingo_db" },
      { "id": 2, "query": "use mongolingo_db" },
      { "id": 3, "query": "select mongolingo_db" },
      { "id": 4, "query": "db.connect(\"mongolingo_db\")" }
    ],
    "correctOptionId": 2,
    "explanation": "La commande **`use <dbname>`** (ici `use mongolingo_db`) est la méthode standard pour basculer vers une base de données existante. Si la base de données n'existe pas, cette commande la crée automatiquement. Les autres options ne sont pas des commandes MongoDB valides pour cette action."
  },
  {
    "numId": 8,
    "description": "Pour trouver tous les étudiants dans la collection `students`, quelle commande utiliserais-tu ?",
    "level": 1,
    "options": [
      { "id": 1, "query": "db.students.getAll()" },
      { "id": 2, "query": "db.students.findMany()" },
      { "id": 3, "query": "db.students.find({})" },
      { "id": 4, "query": "db.students.fetch()" }
    ],
    "correctOptionId": 3,
    "explanation": "La méthode **`find({})`** sans aucun critère de recherche (avec un objet vide `{}`) est la commande correcte pour retourner tous les documents d'une collection. Les options `getAll()`, `findMany()`, et `fetch()` ne sont pas des méthodes standard du shell MongoDB pour cette opération."
  },
  {
    "numId": 9,
    "description": "Quel champ est supposé être unique pour chaque étudiant dans la collection `students` selon le schéma de Mongolingo Campus ?",
    "level": 1,
    "options": [
      { "id": 1, "query": "firstName" },
      { "id": 2, "query": "email" },
      { "id": 3, "query": "lastName" },
      { "id": 4, "query": "coursesFollowed" }
    ],
    "correctOptionId": 2,
    "explanation": "Selon les conventions de modélisation des données et souvent pour l'identification unique dans les systèmes utilisateurs, l'adresse e-mail (**`email`**) est typiquement le champ défini comme unique pour chaque étudiant. `firstName`, `lastName` ou `coursesFollowed` ne garantissent pas l'unicité."
  },
  {
    "numId": 10,
    "description": "Dans MongoDB, quel est l'équivalent d'une 'table' dans une base de données relationnelle ?",
    "level": 1,
    "options": [
      { "id": 1, "query": "Un document" },
      { "id": 2, "query": "Une collection" },
      { "id": 3, "query": "Une base de données" },
      { "id": 4, "query": "Un champ" }
    ],
    "correctOptionId": 2,
    "explanation": "Une **Collection** dans MongoDB est l'équivalent conceptuel d'une table dans une base de données relationnelle, servant à grouper des documents. Un **document** est l'équivalent d'une ligne ou d'un enregistrement, une **base de données** est le conteneur de collections, et un **champ** est une colonne ou un attribut."
  },
  {
    "numId": 11,
    "description": "Tu veux trouver tous les professeurs du département \"Informatique\". Quelle requête est correcte ?",
    "level": 3,
    "options": [
      { "id": 1, "query": "db.professors.find({ department: \"Informatique\" })" },
      { "id": 2, "query": "db.professors.find(\"department\": \"Informatique\")" },
      { "id": 3, "query": "db.professors.where(\"department\" = \"Informatique\")" },
      { "id": 4, "query": "db.professors.filterByDepartment(\"Informatique\")" }
    ],
    "correctOptionId": 1,
    "explanation": "Pour filtrer les documents, on utilise la méthode **`find()`** en lui passant un objet de critères `{ champ: valeur }`. L'option 2 est une syntaxe incorrecte (manque les accolades). Les options 3 et 4 utilisent des méthodes qui n'existent pas ou une syntaxe invalide pour MongoDB."
  },
  {
    "numId": 12,
    "description": "Comment insères-tu un nouveau cours avec le `numId` 500, le titre \"DevOps avec MongoDB\" et une description, dans la collection `courses` ?",
    "level": 3,
    "options": [
      { "id": 1, "query": "db.courses.insert({ numId: 500, title: \"DevOps avec MongoDB\", description: \"...\" })" },
      { "id": 2, "query": "db.courses.add({ numId: 500, title: \"DevOps avec MongoDB\", description: \"...\" })" },
      { "id": 3, "query": "db.courses.createOne({ numId: 500, title: \"DevOps avec MongoDB\", description: \"...\" })" },
      { "id": 4, "query": "db.courses.save({ numId: 500, title: \"DevOps avec MongoDB\", description: \"...\" })" }
    ],
    "correctOptionId": 1,
    "explanation": "La méthode **`insert()`** (ou plus spécifiquement `insertOne()` pour un seul document ou `insertMany()` pour plusieurs) est utilisée pour ajouter de nouveaux documents à une collection. Les autres options (`add()`, `createOne()`, `save()`) ne sont pas des méthodes standard de l'API de base de MongoDB pour l'insertion de documents."
  },
  {
    "numId": 13,
    "description": "Pour mettre à jour l'email de l'étudiant avec `numId: 301` à `\"nouveau.email@example.com\"`, quelle commande utiliserais-tu ?",
    "level": 3,
    "options": [
      { "id": 1, "query": "db.students.update({ numId: 301 }, { email: \"nouveau.email@example.com\" })" },
      { "id": 2, "query": "db.students.replaceOne({ numId: 301 }, { email: \"nouveau.email@example.com\" })" },
      { "id": 3, "query": "db.students.updateOne({ numId: 301 }, { $set: { email: \"nouveau.email@example.com\" } })" },
      { "id": 4, "query": "db.students.edit({ numId: 301 }, { email: \"nouveau.email@example.com\" })" }
    ],
    "correctOptionId": 3,
    "explanation": "La méthode **`updateOne()`** est utilisée pour mettre à jour un seul document. Pour modifier la valeur d'un champ existant sans remplacer tout le document, on utilise l'opérateur **`$set`**. L'option 1 utilise une syntaxe dépréciée ou incomplète sans opérateur. L'option 2 `replaceOne()` remplacerait tout le document, perdant les autres champs. L'option 4 est une méthode inexistante."
  },
  {
    "numId": 14,
    "description": "Un étudiant avec `numId: 301` est inscrit au cours avec `numId: 201`. Comment trouverais-tu toutes ses notes pour ce cours spécifique dans la collection `grades` ?",
    "level": 3,
    "options": [
      { "id": 1, "query": "db.grades.find({ studentId: 301, courseId: 201 })" },
      { "id": 2, "query": "db.grades.find({ grades: { $elemMatch: { studentId: 301, courseId: 201 } } })" },
      { "id": 3, "query": "db.grades.filter({ student: 301, course: 201 })" },
      { "id": 4, "query": "db.grades.getNotes(301, 201)" }
    ],
    "correctOptionId": 1,
    "explanation": "Pour trouver des documents qui correspondent à plusieurs critères, tu peux les combiner directement dans l'objet de filtre de **`find()`** en utilisant une conjonction implicite (AND). L'option 2 est incorrecte car elle cherche dans un champ `grades` inexistant et mal utilisé `$elemMatch`. Les options 3 et 4 sont des méthodes inexistantes."
  },
  {
    "numId": 15,
    "description": "Quel opérateur MongoDB est utilisé pour trouver des documents où la valeur d'un champ est strictement supérieure à une certaine valeur ?",
    "level": 3,
    "options": [
      { "id": 1, "query": "$gt" },
      { "id": 2, "query": "$lt" },
      { "id": 3, "query": "$eq" },
      { "id": 4, "query": "$gte" }
    ],
    "correctOptionId": 1,
    "explanation": "L'opérateur **`$gt`** signifie 'greater than' (strictement supérieur à) et est utilisé pour les comparaisons numériques. `$lt` signifie 'less than', `$eq` signifie 'equal' (mais est implicite si non utilisé), et `$gte` signifie 'greater than or equal' (supérieur ou égal)."
  },
  {
    "numId": 16,
    "description": "Tu veux trouver le nombre moyen de notes (`grade`) pour chaque étudiant dans le cours `numId: 201`. Quelle étape d'agrégation utiliserais-tu après un `$match` sur `courseId` pour calculer cette moyenne par étudiant ?",
    "level": 5,
    "options": [
      { "id": 1, "query": "$sum" },
      { "id": 2, "query": "$avg" },
      { "id": 3, "query": "$group avec $avg" },
      { "id": 4, "query": "$project avec $avg" }
    ],
    "correctOptionId": 3,
    "explanation": "Pour calculer une moyenne **par groupe** (ici, par étudiant), il faut d'abord utiliser l'étape d'agrégation **`$group`** pour regrouper les documents par `studentId`, puis utiliser l'accumulateur **`$avg`** au sein de ce `$group` pour calculer la moyenne des notes pour chaque groupe. `$sum` et `$avg` seuls sont des accumulateurs qui s'utilisent à l'intérieur de `$group` ou `$project` dans certains contextes, mais ne sont pas des étapes d'agrégation autonomes pour ce type de calcul. `$project` est pour remodeler des documents."
  },
  {
    "numId": 17,
    "description": "Comment peux-tu t'assurer qu'un nouveau document dans la collection `courses` ne peut être inséré que si son champ `duration` est entre 1 et 500 inclus, en utilisant la validation de schéma MongoDB ?",
    "level": 5,
    "options": [
      { "id": 1, "query": "db.createCollection(\"courses\", { validator: { $jsonSchema: { properties: { duration: { minimum: 1, maximum: 500 } } } } })" },
      { "id": 2, "query": "db.courses.addValidation({ duration: { $gte: 1, $lte: 500 } })" },
      { "id": 3, "query": "db.courses.setRule({ duration: { $in: [1, 500] } })" },
      { "id": 4, "query": "db.courses.schema({ duration: Number().min(1).max(500) })" }
    ],
    "correctOptionId": 1,
    "explanation": "La validation de schéma est définie lors de la création d'une collection (ou modifiée avec `collMod`) en utilisant l'option **`validator`** et en spécifiant un **`$jsonSchema`**. À l'intérieur du `$jsonSchema`, les mots-clés `minimum` et `maximum` (ou `$gte`/`$lte`) sont utilisés pour définir les contraintes numériques. Les autres options ne sont pas des syntaxes standard pour la validation de schéma MongoDB."
  },
  {
    "numId": 18,
    "description": "Pour trouver tous les cours enseignés par le professeur avec `numId: 101` et projeter uniquement le `title` du cours, quelle requête est la plus simple et appropriée ?",
    "level": 5,
    "options": [
      { "id": 1, "query": "db.courses.find({ professors: 101 }, { title: 1 })" },
      { "id": 2, "query": "db.courses.aggregate([ { $match: { professors: 101 } }, { $project: { title: 1, _id: 0 } } ])" },
      { "id": 3, "query": "db.professors.aggregate([ { $lookup: { from: \"courses\", localField: \"coursesTaught\", foreignField: \"numId\", as: \"taughtCourses\" } }, { $unwind: \"$taughtCourses\" }, { $match: { \"numId\": 101 } }, { $project: { \"taughtCourses.title\": 1, _id: 0 } } ])" },
      { "id": 4, "query": "db.courses.find({ \"professors\": { $in: [101] } }).select(\"title\")" }
    ],
    "correctOptionId": 1,
    "explanation": "Dans ce cas simple de filtre et projection sur une seule collection, la méthode **`find()`** est la plus directe et la plus performante. Elle permet à la fois de filtrer les documents (`{ professors: 101 }`) et de projeter les champs désirés (`{ title: 1 }`). L'option 2 est également valide (utilisation d'agrégation), mais plus complexe que nécessaire pour cette tâche. L'option 3 est une agrégation beaucoup trop complexe qui part des professeurs, alors qu'il est plus simple de partir des cours. L'option 4 utilise `.select()` qui est une méthode Mongoose/pilote Node.js et non une commande du shell MongoDB."
  },
  {
    "numId": 19,
    "description": "Comment peux-tu optimiser les requêtes fréquentes de recherche et de filtrage sur le champ `numId` de la collection `students` ?",
    "level": 5,
    "options": [
      { "id": 1, "query": "En ajoutant un index sur le champ `_id`." },
      { "id": 2, "query": "En ajoutant un index unique sur le champ `email`." },
      { "id": 3, "query": "En ajoutant un index sur le champ `numId`." },
      { "id": 4, "query": "En réorganisant les documents physiquement." }
    ],
    "correctOptionId": 3,
    "explanation": "Créer un **index sur le champ `numId`** (`db.students.createIndex({ numId: 1 })`) est la méthode la plus efficace pour accélérer les requêtes de recherche et de tri sur ce champ. L'index `_id` est déjà unique et par défaut, mais n'aide pas pour les requêtes sur `numId`. Un index sur `email` n'aiderait que les requêtes sur `email`. La réorganisation physique n'est pas une méthode d'optimisation standard et automatique dans MongoDB."
  },
  {
    "numId": 20,
    "description": "Tu veux récupérer les noms complets (`firstName` et `lastName`) de tous les étudiants qui suivent le cours \"Introduction à MongoDB\". Quelle est la meilleure approche en utilisant l'agrégation et le `$lookup` ?",
    "level": 5,
    "options": [
      { "id": 1, "query": "Chercher le `numId` du cours, puis trouver les étudiants avec ce `numId` dans `coursesFollowed`, puis projeter." },
      { "id": 2, "query": "db.students.aggregate([ { $lookup: { from: \"courses\", localField: \"coursesFollowed\", foreignField: \"numId\", as: \"enrolledCourses\" } }, { $match: { \"enrolledCourses.title\": \"Introduction à MongoDB\" } }, { $project: { fullName: { $concat: [\"$firstName\", \" \", \"$lastName\"] }, _id: 0 } } ])" },
      { "id": 3, "query": "db.courses.aggregate([ { $match: { title: \"Introduction à MongoDB\" } }, { $lookup: { from: \"students\", localField: \"numId\", foreignField: \"coursesFollowed\", as: \"studentsEnrolled\" } }, { $unwind: \"$studentsEnrolled\" }, { $project: { fullName: { $concat: [\"$studentsEnrolled.firstName\", \" \", \"$studentsEnrolled.lastName\"] }, _id: 0 } } ])" },
      { "id": 4, "query": "Les options 2 et 3 sont toutes les deux de bonnes approches d'agrégation." }
    ],
    "correctOptionId": 4,
    "explanation": "Les deux requêtes d'agrégation (Options 2 et 3) sont des approches valides et efficaces pour résoudre ce problème de jointure et de filtrage. L'option 2 part de la collection `students` et joint les `courses`, tandis que l'option 3 part de la collection `courses` et joint les `students`. Les deux utilisent correctement **`$lookup`** pour la jointure, **`$match`** pour le filtrage, et **`$project`** avec **`$concat`** pour formater le nom complet, démontrant la flexibilité de l'agrégation."
  }
]